// Code generated by MockGen. DO NOT EDIT.

package testutil

import (
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"

	types "github.com/cosmos/cosmos-sdk/types"
)

// MockCrossChainApplication is a mock of CrossChainApplication interface
type MockCrossChainApplication struct {
	ctrl     *gomock.Controller
	recorder *MockCrossChainApplicationMockRecorder
}

// MockCrossChainApplicationMockRecorder is the mock recorder for MockCrossChainApplication
type MockCrossChainApplicationMockRecorder struct {
	mock *MockCrossChainApplication
}

// NewMockCrossChainApplication creates a new mock instance
func NewMockCrossChainApplication(ctrl *gomock.Controller) *MockCrossChainApplication {
	mock := &MockCrossChainApplication{ctrl: ctrl}
	mock.recorder = &MockCrossChainApplicationMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockCrossChainApplication) EXPECT() *MockCrossChainApplicationMockRecorder {
	return m.recorder
}

// ExecuteSynPackage mocks base method
func (m *MockCrossChainApplication) ExecuteSynPackage(ctx types.Context, appCtx *types.CrossChainAppContext, payload []byte) types.ExecuteResult {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExecuteSynPackage", ctx, payload)
	ret0, _ := ret[0].(types.ExecuteResult)
	return ret0
}

// ExecuteSynPackage indicates an expected call of ExecuteSynPackage
func (mr *MockCrossChainApplicationMockRecorder) ExecuteSynPackage(ctx, header, payload, relayerFee interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecuteSynPackage", reflect.TypeOf((*MockCrossChainApplication)(nil).ExecuteSynPackage), ctx, payload, relayerFee)
}

// ExecuteAckPackage mocks base method
func (m *MockCrossChainApplication) ExecuteAckPackage(ctx types.Context, header *types.CrossChainAppContext, payload []byte) types.ExecuteResult {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExecuteAckPackage", ctx, payload)
	ret0, _ := ret[0].(types.ExecuteResult)
	return ret0
}

// ExecuteAckPackage indicates an expected call of ExecuteAckPackage
func (mr *MockCrossChainApplicationMockRecorder) ExecuteAckPackage(ctx, header, payload interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecuteAckPackage", reflect.TypeOf((*MockCrossChainApplication)(nil).ExecuteAckPackage), ctx, payload)
}

// ExecuteFailAckPackage mocks base method
func (m *MockCrossChainApplication) ExecuteFailAckPackage(ctx types.Context, header *types.CrossChainAppContext, payload []byte) types.ExecuteResult {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExecuteFailAckPackage", ctx, payload)
	ret0, _ := ret[0].(types.ExecuteResult)
	return ret0
}

// ExecuteFailAckPackage indicates an expected call of ExecuteFailAckPackage
func (mr *MockCrossChainApplicationMockRecorder) ExecuteFailAckPackage(ctx, header, payload interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecuteFailAckPackage", reflect.TypeOf((*MockCrossChainApplication)(nil).ExecuteFailAckPackage), ctx, payload)
}
